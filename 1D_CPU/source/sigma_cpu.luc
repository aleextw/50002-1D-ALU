module sigma_cpu (
    input clk,              // 100MHz clock
    input rst,            // reset button (active low)
    input buttons [16],   // Button input
    output level [16],
    output pegs [16],
    output selected_peg [16],
    output val_move [16]
  ) {
  
  const NUM_DATA = 84;
  
  .clk(clk) {
    button_conditioner button_cond[16] (#CLK_FREQ(100000000), #MIN_DELAY(40));
    edge_detector edge_det[16] (#RISE(1), #FALL(0));
    
    alu arith;
    regfile rf;
    data_mem data;
    pc_unit pc;
    
    fsm ram_writer = {LOAD, WAIT, GO};
    dff writer_counter[$clog2(NUM_DATA) + 1];
    
    edge_detector slow_clock_edge_detector (#RISE(1), #FALL(1));
    
    .rst(rst) {
      counter cnt(#SIZE(1), #DIV(16));
    }
  }
  
  cu cu;
  inst_mem instructions;
  data_rom drom;
  
  always {      
    rf.we = 0;
    if (slow_clock_edge_detector.out) {
      rf.we = cu.werf;
    }
    
    arith.slow_clock = slow_clock_edge_detector.out;
    
    button_cond.in = buttons;
    edge_det.in = button_cond.out;
    
    // Program Counter
    slow_clock_edge_detector.in = cnt.value;
    pc.slow_clock = slow_clock_edge_detector.out;
    pc.rst = rst;
    instructions.ia = pc.ia;
    pc.id = instructions.id[15:0];
    pc.pcsel = cu.pcsel;
    pc.ra = rf.rd1;
    
    // Control Unit
    cu.rst = rst;
    cu.z = ~|rf.rd1;
    cu.id = instructions.id[31:26];
    arith.alufn = cu.alufn;
    data.wr = cu.wr;
    
    // Regfile
    case(cu.ra2sel) {
      0: rf.ra2 = instructions.id[15:11];
      1: rf.ra2 = instructions.id[25:21];
      default: rf.ra2 = instructions.id[15:11];
    }
    rf.ra1 = instructions.id[20:16];
    
    case(cu.wasel) {
      0: rf.wa = instructions.id[25:21];
      1: rf.wa = b11110;
      default: rf.wa = instructions.id[25:21];
    }
    rf.buttons = edge_det.out;
    
    // TODO: LED Outputs
    pegs = rf.pegs;
    level = rf.level;
    selected_peg = rf.selected_peg;
    val_move = rf.val_move;
    
    // ALU
    arith.rst = rst;
    case (cu.bsel) {
      0: arith.b = rf.rd2;
      1: arith.b = instructions.id[15:0];
      default: arith.b = rf.rd2;
    }
    
    arith.a = rf.rd1;
    case(cu.wdsel) {
      0: rf.wd = c{pc.ia[15], pc.pc_4[14:0]};
      1: rf.wd = arith.out;
      2: rf.wd = data.out;
      default: rf.wd = arith.out;
    }
    
    // Data Memory
    data.addr = arith.out;
    data.wd = rf.rd2;
    
    drom.address = writer_counter.q;
    case (ram_writer.q) {
      ram_writer.LOAD:
        cu.rst = 1;
        writer_counter.d = writer_counter.q + 1;
        data.wr = 1;
        data.addr = writer_counter.q << 1;
        data.wd = drom.out;
        if (writer_counter.q == NUM_DATA) {
          ram_writer.d = ram_writer.WAIT;
        }
      ram_writer.WAIT:
        cu.rst = 1;
        data.wr = 0;
        data.addr = writer_counter.q << 1;
        data.wd = drom.out;
        ram_writer.d = ram_writer.GO;
      ram_writer.GO:
        data.addr = arith.out;
        data.wd = rf.rd2;
        data.wr = cu.wr;
        ram_writer.d = ram_writer.GO;
    }
  }
}
