module sigma_cpu (
    input clk,              // 100MHz clock
    input rst,            // reset button (active low)
    input io_button [5],    // 5 buttons on IO Shield
    input buttons [16],   // DIP switches on IO Shield
    input clk_dip,
    output led [8],         // 8 user controllable LEDs
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],     // Digit select on IO Shield
    output level [16],
    output pegs [16],
    output selected_peg [16],
    output val_move [16],
    output space_check [16],
    output possible [16]
  ) {
  
  const NUM_DATA = 78;
  
  bin_to_dec btd(#DIGITS(16));
  decoder ss_sel_dec(#WIDTH(2));
  seven_seg ss;
  
  .clk(clk) {
    // button_conditioner button_cond[16];
    edge_detector edge_det[16] (#RISE(1), #FALL(0));
    
    button_conditioner io_cnd;
    button_conditioner dip_cnd;
    
    alu arith;
    regfile rf;
    data_mem data;
    pc_unit pc;
    
    fsm ram_writer = {LOAD, WAIT, GO};
    dff writer_counter[$clog2(NUM_DATA) + 1];
    
    edge_detector slow_clock_edge_detector (#RISE(1), #FALL(1));
    
    .rst(rst) {
      counter cnt(#SIZE(1), #DIV(26));
      counter ss_sel(#SIZE(2), #TOP(3), #DIV(16));
    }
  }
  
  cu cu;
  inst_mem instructions;
  data_rom drom;
  
  always {      
    rf.we = 0;
    if (slow_clock_edge_detector.out & (io_cnd.out | dip_cnd.out)) {
      rf.we = cu.werf;
    }
    
    arith.slow_clock = slow_clock_edge_detector.out;
    
    led = 8h00;             // turn LEDs off

    io_led = 3x{{8h00}};    // turn LEDs off
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits
    
    io_cnd.in = io_button[0];
    dip_cnd.in = clk_dip;
    
    // Display PC on 7-segment display
    ss_sel_dec.in = ss_sel.value;
    btd.value = pc.ia;
    ss.char = btd.digits[ss_sel.value];
    io_sel = ~ss_sel_dec.out;
    io_seg = ~ss.segs;
    
    io_cnd.in = io_button[0];
    // edge_det.in = button_cond.out;
    edge_det.in = buttons[15:0];
    
    // Program Counter
    slow_clock_edge_detector.in = cnt.value;
    pc.slow_clock = slow_clock_edge_detector.out & (io_cnd.out | dip_cnd.out);
    // pc.but = io_cnd.out;
    pc.rst = rst;
    instructions.ia = pc.ia;
    pc.id = instructions.id[15:0];
    pc.pcsel = cu.pcsel;
    pc.ra = rf.rd1;
    
    // Control Unit
    cu.rst = rst;
    cu.z = ~|rf.rd1;
    cu.id = instructions.id[31:26];
    arith.alufn = cu.alufn;
    data.wr = cu.wr;
    
    // Regfile
    case(cu.ra2sel) {
      0: rf.ra2 = instructions.id[15:11];
      1: rf.ra2 = instructions.id[25:21];
      default: rf.ra2 = instructions.id[15:11];
    }
    rf.ra1 = instructions.id[20:16];
    
    case(cu.wasel) {
      0: rf.wa = instructions.id[25:21];
      1: rf.wa = b11110;
      default: rf.wa = instructions.id[25:21];
    }
    rf.buttons = edge_det.out;
    
    // TODO: LED Outputs
    pegs = rf.pegs;
    level = rf.level;
    selected_peg = rf.selected_peg;
    val_move = rf.val_move;
    space_check = rf.space_check;
    possible = rf.possible;
    
    led[0] = cnt.value;
    led[7:1] = pc.ia[6:0];
    
    // ALU
    arith.rst = rst;
    case (cu.bsel) {
      0: arith.b = rf.rd2;
      1: arith.b = instructions.id[15:0];
      default: arith.b = rf.rd2;
    }
    
    arith.a = rf.rd1;
    case(cu.wdsel) {
      0: rf.wd = c{pc.ia[15], pc.pc_4[14:0]};
      1: rf.wd = arith.out;
      2: rf.wd = data.out;
      default: rf.wd = arith.out;
    }
    
    // Data Memory
    data.addr = arith.out;
    data.wd = rf.rd2;
    
    drom.address = writer_counter.q;
    case (ram_writer.q) {
      ram_writer.LOAD:
        cu.rst = 1;
        writer_counter.d = writer_counter.q + 1;
        data.wr = 1;
        data.addr = writer_counter.q << 1;
        data.wd = drom.out;
        if (writer_counter.q == NUM_DATA) {
          ram_writer.d = ram_writer.WAIT;
        }
      ram_writer.WAIT:
        cu.rst = 1;
        data.wr = 0;
        data.addr = writer_counter.q << 1;
        data.wd = drom.out;
        ram_writer.d = ram_writer.GO;
      ram_writer.GO:
        data.addr = arith.out;
        data.wd = rf.rd2;
        data.wr = cu.wr;
        ram_writer.d = ram_writer.GO;
    }
  }
}
