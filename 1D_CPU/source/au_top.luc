module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input usb_rx,           // USB->Serial input
    output usb_tx,          // USB->Serial output
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8]     // DIP switches on IO Shield
  ) {
  
  sig rst;                  // reset signal
  
  const NUM_DATA = 54;
  
  bin_to_dec btd(#DIGITS(16));
  decoder ss_sel_dec(#WIDTH(2));
  seven_seg ss;
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    // button_conditioner button_cond[16];
    edge_detector edge_det[16] (#RISE(1), #FALL(0));
    
    button_conditioner io_cnd;
    button_conditioner dip_cnd;
    
    alu arith;
    regfile rf;
    data_mem data;
    pc_unit pc;
    
    fsm ram_writer = {LOAD, WAIT, GO};
    dff writer_counter[$clog2(NUM_DATA) + 1];
    
    edge_detector slow_clock_edge_detector (#RISE(1), #FALL(1));
    
    .rst(rst) {
      counter cnt(#SIZE(1), #DIV(26));
      counter ss_sel(#SIZE(2), #TOP(3), #DIV(16));
    }
  }
  
 
  
  cu cu;
  inst_mem instructions;
  data_rom drom;
  
  always {      
    rf.we = 0;
    if (slow_clock_edge_detector.out & (io_cnd.out | dip_cnd.out)) {
      rf.we = cu.werf;
    }
    
    arith.slow_clock = slow_clock_edge_detector.out;
    
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    led = 8h00;             // turn LEDs off

    io_led = 3x{{8h00}};    // turn LEDs off
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits
    
    usb_tx = usb_rx;        // echo the serial data
    
    io_cnd.in = io_button[0];
    dip_cnd.in = io_dip[0][0];
    
    // Display PC on 7-segment display
    ss_sel_dec.in = ss_sel.value;
    btd.value = pc.ia;
    ss.char = btd.digits[ss_sel.value];
    io_sel = ~ss_sel_dec.out;
    io_seg = ~ss.segs;
    
    io_cnd.in = io_button[0];
    // edge_det.in = button_cond.out;
    edge_det.in = $flatten(io_dip[2:1]);
    
    // Program Counter
    slow_clock_edge_detector.in = cnt.value;
    pc.slow_clock = slow_clock_edge_detector.out & (io_cnd.out | dip_cnd.out);
    // pc.but = io_cnd.out;
    pc.rst = rst;
    instructions.ia = pc.ia;
    pc.id = instructions.id[15:0];
    pc.pcsel = cu.pcsel;
    pc.ra = rf.rd1;
    
    // Control Unit
    cu.rst = rst;
    cu.z = ~|rf.rd1;
    cu.id = instructions.id[31:26];
    arith.alufn = cu.alufn;
    data.wr = cu.wr;
    
    // Regfile
    case(cu.ra2sel) {
      0: rf.ra2 = instructions.id[15:11];
      1: rf.ra2 = instructions.id[25:21];
      default: rf.ra2 = instructions.id[15:11];
    }
    rf.ra1 = instructions.id[20:16];
    
    case(cu.wasel) {
      0: rf.wa = instructions.id[25:21];
      1: rf.wa = b11110;
      default: rf.wa = instructions.id[25:21];
    }
    rf.buttons = edge_det.out;
    rf.ia = pc.ia[10];  // Kind of janky, but gives us 256 instructions before the SVC handler (change if more instruction space is needed)
    
    // TODO: LED Outputs
    io_led[2] = rf.peg[7:0];
    // io_led[2] = rf.peg[7:0];
    // io_led[1] = rf.val_op[7:0];
    io_led[1:0] = $build(arith.out, 2);
    // io_led[2:1] = $build(rf.sel_but, 2);
    
    // io_led[2] = rf.rd1[7:0];
    // io_led[1] = rf.rd2[7:0];
    
    // io_led[2] = data.out[7:0];
    // io_led[1] = arith.out[7:0];
    // io_led[0] = rf.peg[7:0];
    
    led[0] = cnt.value;
    led[7:1] = pc.ia[6:0];
    
    // ALU
    arith.rst = rst;
    case (cu.bsel) {
      0: arith.b = rf.rd2;
      1: arith.b = instructions.id[15:0];
      default: arith.b = rf.rd2;
    }
    
    arith.a = rf.rd1;
    case(cu.wdsel) {
      0: rf.wd = c{pc.ia[15], pc.pc_4[14:0]};
      1: rf.wd = arith.out;
      2: rf.wd = data.out;
      default: rf.wd = arith.out;
    }
    
    // Data Memory
    data.addr = arith.out;
    data.wd = rf.rd2;
    
    drom.address = writer_counter.q;
    case (ram_writer.q) {
      ram_writer.LOAD:
        cu.rst = 1;
        writer_counter.d = writer_counter.q + 1;
        data.wr = 1;
        data.addr = writer_counter.q << 1;
        data.wd = drom.out;
        if (writer_counter.q == NUM_DATA) {
          ram_writer.d = ram_writer.WAIT;
        }
      ram_writer.WAIT:
        cu.rst = 1;
        data.wr = 0;
        data.addr = writer_counter.q << 1;
        data.wd = drom.out;
        ram_writer.d = ram_writer.GO;
      ram_writer.GO:
        data.addr = arith.out;
        data.wd = rf.rd2;
        data.wr = cu.wr;
        ram_writer.d = ram_writer.GO;
    }
  }
}