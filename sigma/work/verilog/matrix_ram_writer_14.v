/*
   This file was generated automatically by Alchitry Labs version 1.2.7.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

/*
   Parameters:
     ADDRESS_SIZE = 4
     MATRIX_WIDTH = 64
     DATA_WIDTH = 16
     DATA_SET = 3
*/
module matrix_ram_writer_14 (
    input clk,
    input rst,
    input reload,
    input [47:0] new_data,
    output reg [3:0] row_address_top,
    output reg [5:0] col_address_top,
    output reg we_top,
    output reg [2:0] wd_top,
    output reg [3:0] row_address_btm,
    output reg [5:0] col_address_btm,
    output reg we_btm,
    output reg [2:0] wd_btm,
    output reg ready
  );
  
  localparam ADDRESS_SIZE = 3'h4;
  localparam MATRIX_WIDTH = 7'h40;
  localparam DATA_WIDTH = 5'h10;
  localparam DATA_SET = 2'h3;
  
  
  
  localparam START_writer_state = 2'd0;
  localparam LOAD_ADDRESS_writer_state = 2'd1;
  localparam LOAD_WAIT_writer_state = 2'd2;
  localparam LOOP_writer_state = 2'd3;
  
  reg [1:0] M_writer_state_d, M_writer_state_q = START_writer_state;
  
  localparam START_DATA = 48'h000203007fff;
  
  localparam MAPPING = 192'h00024e24c24a24824620d20b2092071cc1ca1c818b18914a;
  
  reg [3:0] M_bitloader_d, M_bitloader_q = 1'h0;
  
  reg [47:0] M_data_d, M_data_q = 1'h0;
  
  reg [5:0] M_data_col_address_d, M_data_col_address_q = 1'h0;
  
  reg [3:0] M_data_row_address_d, M_data_row_address_q = 1'h0;
  
  reg [9:0] M_ram_writer_address_d, M_ram_writer_address_q = 1'h0;
  
  always @* begin
    M_writer_state_d = M_writer_state_q;
    M_data_d = M_data_q;
    M_bitloader_d = M_bitloader_q;
    M_data_col_address_d = M_data_col_address_q;
    
    ready = 1'h0;
    we_top = 1'h0;
    we_btm = 1'h0;
    row_address_top = 1'h0;
    row_address_btm = 1'h0;
    col_address_top = 1'h0;
    col_address_btm = 1'h0;
    wd_top = 1'h0;
    wd_btm = 1'h0;
    
    case (M_writer_state_q)
      START_writer_state: begin
        M_data_d = 48'h000203007fff;
        M_writer_state_d = LOAD_ADDRESS_writer_state;
      end
      LOAD_ADDRESS_writer_state: begin
        row_address_top = MAPPING[(M_bitloader_q)*12+6+5-:6];
        col_address_top = MAPPING[(M_bitloader_q)*12+0+5-:6];
        row_address_btm = M_data_row_address_q;
        col_address_btm = M_data_col_address_q;
        wd_top = 3'h0;
        if (M_data_q[32+(M_bitloader_q)*1+0-:1] == 1'h1) begin
          wd_top = 3'h4;
        end else begin
          if (M_data_q[16+(M_bitloader_q)*1+0-:1] == 1'h1) begin
            wd_top = 3'h2;
          end else begin
            if (M_data_q[0+(M_bitloader_q)*1+0-:1] == 1'h1) begin
              wd_top = 3'h1;
            end
          end
        end
        wd_btm = 3'h4;
        we_top = 1'h1;
        we_btm = 1'h1;
        M_writer_state_d = LOAD_WAIT_writer_state;
        if ((&M_bitloader_q) == 1'h1) begin
          M_bitloader_d = 1'h0;
          M_writer_state_d = LOOP_writer_state;
        end
      end
      LOAD_WAIT_writer_state: begin
        M_bitloader_d = M_bitloader_q + 1'h1;
        M_data_col_address_d = M_data_col_address_q + 1'h1;
        M_writer_state_d = LOAD_ADDRESS_writer_state;
      end
      LOOP_writer_state: begin
        ready = 1'h1;
        M_writer_state_d = LOOP_writer_state;
        if (reload) begin
          M_data_d = new_data;
          M_writer_state_d = LOAD_ADDRESS_writer_state;
        end
      end
    endcase
  end
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_data_q <= 1'h0;
    end else begin
      M_data_q <= M_data_d;
    end
  end
  
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_bitloader_q <= 1'h0;
    end else begin
      M_bitloader_q <= M_bitloader_d;
    end
  end
  
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_data_row_address_q <= 1'h0;
    end else begin
      M_data_row_address_q <= M_data_row_address_d;
    end
  end
  
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_writer_state_q <= 1'h0;
    end else begin
      M_writer_state_q <= M_writer_state_d;
    end
  end
  
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_data_col_address_q <= 1'h0;
    end else begin
      M_data_col_address_q <= M_data_col_address_d;
    end
  end
  
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_ram_writer_address_q <= 1'h0;
    end else begin
      M_ram_writer_address_q <= M_ram_writer_address_d;
    end
  end
  
endmodule
