/*
   Answer ROM: This module stores the correct output {out, z, v, n} of our ALU 
   given a set of input values {a, b, alufn} (passed as an address to this module).
   
   Since the z, v, n outputs of the ALU are technically still valid even during other
   non-addition/subtraction operations, we checked their validity as well by setting the
   adder with the last bit of the ALUFN, and taking the z, v, n values corresponding to the
   a and b inputs.
*/

module answer_rom (
    input address[38],    // address formatted as c{a, b, alufn}
    output out[19]        // out formatted as c{alu_out, z, v, n}
  ) {
  always {
    case(address) {
      // Add test cases
      b00000000000000000000000000000000000000: out = b0000000000000000100;  // 0 + 0 = 0
      b01111111111111110000000000000000000000: out = b0111111111111111000;  // x + 0 = x
      b00000000000000000111111111111111000000: out = b0111111111111111000;  // 0 + x = x
      b11111111111111110000000000000000000000: out = b1111111111111111001;  // (-x) + 0 = (-x)
      b00000000000000001111111111111111000000: out = b1111111111111111001;  // 0 + (-x) = (-x)
      b00010010001101000011010001010110000000: out = b0100011010001010000;  // 0x1234 + 0x3456 = 0x468A (Positive addition)
      b11111000000000011111100000100000000000: out = b1111000000100001001;  // 0xF801 + 0xF820 = 0xF021 (Negative addition)
      b11011110000000000000000010101101000000: out = b1101111010101101001;  // Negative + Positive
      b00000000111011111011111000000000000000: out = b1011111011101111001;  // Positive + Negative
      b11111111111111111111111111111111000000: out = b1111111111111110001;  // 0xFFFF + 0xFFFF = 0xFFFE
      b01110000000000000111000000000000000000: out = b1110000000000000011;  // Positive overflow
      b11111111111111110000000000000001000000: out = b0000000000000000100;  // Negative overflow
      
      // Subtract test cases
      b00000000000000000000000000000000000001: out = b0000000000000000100;  // 0 - 0 = 0
      b01111111111111110000000000000000000001: out = b0111111111111111000;  // x - 0 = x
      b00000000000000000111111111111111000001: out = b1000000000000001001;  // 0 - x = -x
      b11111111111111110000000000000000000001: out = b1111111111111111001;  // (-x) - 0 = (-x)
      b00000000000000000111111111111111000001: out = b1000000000000001001;  // 0 - (-x) = x
      b01110110010101000101010000110010000001: out = b0010001000100010000;  // x - y, x > y > 0
      b01010100001100100111011001010100000001: out = b1101110111011110001;  // x - y, y > x > 0
      b11101101110010111101110010111010000001: out = b0001000100010001000;  // x - y, 0 > x > y
      b11011100101110101110110111001011000001: out = b1110111011101111001;  // x - y, 0 > y > x
      b01111111111111111000000000000000000001: out = b1111111111111111011;  // x - y, x > 0 > y
      b10000000000000000111111111111111000001: out = b0000000000000001010;  // x - y, y > 0 > x
      
      // Multiplication
      b00000000000000000000000000000000000100: out = b0000000000000000100;  // 0 x 0
      b00000000000000000111111111111111000100: out = b0000000000000000000;  // 0 x Positive
      b00000000000000001111111111111111000100: out = b0000000000000000001;  // 0 x Negative
      b01111111111111110000000000000000000100: out = b0000000000000000000;  // Positive x 0
      b11111111111111110000000000000000000100: out = b0000000000000000001;  // Negative x 0
      b00000000000001010000000000000011000100: out = b0000000000001111000;  // 5 x 3 = 15
      b00000000000001011111111111111111000100: out = b1111111111111011000;  // 5 x -1 = -5
      b11111111111111100000000000000100000100: out = b1111111111111000000;  // -2 x 4 = -8
      b11111111111111101111111111111101000100: out = b0000000000000110001;  // -2 x -3 = 6
      b01111111111111110111000000000000000100: out = b1001000000000000011;  // 32 767 x 28 672 = -28 672
      b10000000000000001000111111111111000100: out = b1000000000000000010;  // -32 768 x -28 673 = -32 768
      
      // Boolean
      // XOR
      b00000000000000000000000000000000010000: out = b0000000000000000100;  // 0x0000 ^ 0x0000 = 0x0000
      b11111111111111111111111111111111010000: out = b0000000000000000001;  // 0xFFFF ^ 0xFFFF = 0x0000
      b11111111111111110000000000000000010000: out = b1111111111111111001;  // 0xFFFF ^ 0x0000 = 0xFFFF
      b01010101010101011010101010101010010000: out = b1111111111111111001;  // 0x5555 ^ 0xAAAA = 0x1111
      b11111111111111110101010101010101010000: out = b1010101010101010000;  // 0xFFFF ^ 0x5555 = 0xAAAA
      // AND
      b00000000000000000000000000000000010001: out = b0000000000000000100;  // 0x0000 * 0x0000 = 0x0000
      b11111111111111111111111111111111010001: out = b1111111111111111100;  // 0xFFFF * 0xFFFF = 0xFFFF
      b11111111111111110000000000000000010001: out = b0000000000000000001;  // 0xFFFF * 0x0000 = 0x0000
      b01010101010101011010101010101010010001: out = b0000000000000000011;  // 0x5555 * 0xAAAA = 0x0000
      b11011110101011010000000011111111010001: out = b0000000010101101001;  // 0xDEAD * 0x00FF = 0x00AD
      // "A"
      b00000000000000000000000000000000010010: out = b0000000000000000100;  
      b11111111111111110000000000000000010010: out = b1111111111111111001;
      b10111110111011110000000000000000010010: out = b1011111011101111001;
      b00010010001101001010101111001101010010: out = b0001001000110100001;  // Value of B doesn't affect output of ALU
      // OR
      b00000000000000000000000000000000010011: out = b0000000000000000100;  // Self-explanatory
      b11111111111111111111111111111111010011: out = b1111111111111111100;
      b11111111111111110000000000000000010011: out = b1111111111111111001;
      b01010101010101011010101010101010010011: out = b1111111111111111011;
      b11011110000000000000000010101101010011: out = b1101111010101101001;
      
      // Bitshift
      // shift left
      b11011110101011010000000000000101100000: out = b1101010110100000001;  // Shift to non-byte boundary
      b11011110101011010000000000001000100000: out = b1010110100000000001;  // Shift to byte boundary
      b11011110101011010000000000001111100000: out = b1000000000000000001;  // Shift to max shift
      // shift right
      b11011110101011010000000000000101100001: out = b0000011011110101001;  // Shift to non-byte boundary
      b11011110101011010000000000001000100001: out = b0000000011011110001;  // Shift to byte boundary
      b11011110101011010000000000001111100001: out = b0000000000000001001;  // Shift to max shift
      // shift right arithmetic
      // Negative value
      b11011110101011010000000000000101100010: out = b1111111011110101001;  // Shift to non-byte boundary
      b11011110101011010000000000001000100010: out = b1111111111011110001;  // Shift to byte boundary
      b11011110101011010000000000001111100010: out = b1111111111111111001;  // Shift to max shift
      // Positive value
      b01111100101010110000000000000101100010: out = b0000001111100101000;  // Shift to non-byte boundary
      b01111100101010110000000000001000100010: out = b0000000001111100000;  // Shift to byte boundary
      b01111100101010110000000000001111100010: out = b0000000000000000000;  // Shift to max shift
      // rotate left
      b11011110101011010000000000000101100011: out = b1101010110111011001;  // Rotate to non-byte boundary
      b11011110101011010000000000001000100011: out = b1010110111011110001;  // Rotate to byte boundary
      b11011110101011010000000000001111100011: out = b1110111101010110001;  // Rotate to max position
      // rotate right
      b11011110101011010000000000000101100100: out = b0110111011110101001;  // Rotate to non-byte boundary
      b11011110101011010000000000001000100100: out = b1010110111011110001;  // Rotate to byte boundary
      b11011110101011010000000000001111100100: out = b1011110101011011001;  // Rotate to max position
      
      // Comparison
      // CMPEQ
      b10000000000000001111111111111111110011: out = b0000000000000000001;  // Less than (Negative - Negative)
      b10000000000000000000000000000000110011: out = b0000000000000000001;  // Less than (Negative - Zero)
      b10000000000000000111111111111111110011: out = b0000000000000000010;  // Less than (Negative - Positive)
      b00000000000000000111111111111111110011: out = b0000000000000000001;  // Less than (Zero - Positive)
      b00000000000000010111111111111111110011: out = b0000000000000000001;  // Less than (Positive - Positive)
      
      b10000000000000001000000000000000110011: out = b0000000000000001100;  // Equal to (Negative - Negative)
      b00000000000000000000000000000000110011: out = b0000000000000001100;  // Equal to (Zero - Zero)
      b01111111111111110111111111111111110011: out = b0000000000000001100;  // Equal to (Positive - Positive)
      
      b11111111111111111000000000000000110011: out = b0000000000000000000;  // Greater than (Negative - Negative)
      b00000000000000001000000000000000110011: out = b0000000000000000011;  // Greater than (Zero - Negative)
      b01111111111111111000000000000000110011: out = b0000000000000000011;  // Greater than (Positive - Negative)
      b01111111111111110000000000000000110011: out = b0000000000000000000;  // Greater than (Positive - Zero)
      b01111111111111110000000000000001110011: out = b0000000000000000000;  // Greater than (Positive - Positive)
      
      // CMPLT
      b10000000000000001111111111111111110101: out = b0000000000000001001;  // Less than (Negative - Negative)
      b10000000000000000000000000000000110101: out = b0000000000000001001;  // Less than (Negative - Zero)
      b10000000000000000111111111111111110101: out = b0000000000000001010;  // Less than (Negative - Positive)
      b00000000000000000111111111111111110101: out = b0000000000000001001;  // Less than (Zero - Positive)
      b00000000000000010111111111111111110101: out = b0000000000000001001;  // Less than (Positive - Positive)
      
      b10000000000000001000000000000000110101: out = b0000000000000000100;  // Equal to (Negative - Negative)
      b00000000000000000000000000000000110101: out = b0000000000000000100;  // Equal to (Zero - Zero)
      b01111111111111110111111111111111110101: out = b0000000000000000100;  // Equal to (Positive - Positive)
      
      b11111111111111111000000000000000110101: out = b0000000000000000000;  // Greater than (Negative - Negative)
      b00000000000000001000000000000000110101: out = b0000000000000000011;  // Greater than (Zero - Negative)
      b01111111111111111000000000000000110101: out = b0000000000000000011;  // Greater than (Positive - Negative)
      b01111111111111110000000000000000110101: out = b0000000000000000000;  // Greater than (Positive - Zero)
      b01111111111111110000000000000001110101: out = b0000000000000000000;  // Greater than (Positive - Positive)
      
      // CMPLE
      b10000000000000001111111111111111110111: out = b0000000000000001001;  // Less than (Negative - Negative)
      b10000000000000000000000000000000110111: out = b0000000000000001001;  // Less than (Negative - Zero)
      b10000000000000000111111111111111110111: out = b0000000000000001010;  // Less than (Negative - Positive)
      b00000000000000000111111111111111110111: out = b0000000000000001001;  // Less than (Zero - Positive)
      b00000000000000010111111111111111110111: out = b0000000000000001001;  // Less than (Positive - Positive)
      
      b10000000000000001000000000000000110111: out = b0000000000000001100;  // Equal to (Negative - Negative)
      b00000000000000000000000000000000110111: out = b0000000000000001100;  // Equal to (Zero - Zero)
      b01111111111111110111111111111111110111: out = b0000000000000001100;  // Equal to (Positive - Positive)
      
      b11111111111111111000000000000000110111: out = b0000000000000000000;  // Greater than (Negative - Negative)
      b00000000000000001000000000000000110111: out = b0000000000000000011;  // Greater than (Zero - Negative)
      b01111111111111111000000000000000110111: out = b0000000000000000011;  // Greater than (Positive - Negative)
      b01111111111111110000000000000000110111: out = b0000000000000000000;  // Greater than (Positive - Zero)
      b01111111111111110000000000000001110111: out = b0000000000000000000;  // Greater than (Positive - Positive)
      
      default: out = c{16h0, 0, 0, 0}; // Hopefully we never reach here, but if we do, output all zeroes
    }
  }
}