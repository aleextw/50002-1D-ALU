module answer_rom (
    input address[38],    // address formatted as c{a, b, alufn}
    output out[19]        // out formatted as c{alu_out, z, v, n}
  ) {
  always {
    case(address) {
      // Add test cases
      00000000000000000000000000000000000000: out = 0000000000000000100;     // 0 + 0 = 0
      01111111111111110000000000000000000000: out = 0111111111111111000;     // x + 0 = x
      00000000000000000111111111111111000000: out = 0111111111111111000;     // 0 + x = x
      11111111111111110000000000000000000000: out = 1111111111111111001;     // (-x) + 0 = (-x)
      00000000000000001111111111111111000000: out = 1111111111111111001;     // 0 + (-x) = (-x)
      00010010001101000011010001010110000000: out = 0100011010001010000;     // 0x1234 + 0x3456 = 0x468A (Positive addition)
      11111000000000011111100000100000000000: out = 1111000000100001001;     // 0xF801 + 0xF820 = 0xF021 (Negative addition)
      11011110000000000000000010101101000000: out = 1101111010101101001;     // Negative + Positive
      00000000111011111011111000000000000000: out = 1011111011101111001;     // Positive + Negative
      11111111111111111111111111111111000000: out = 1111111111111110001;     // 0xFFFF + 0xFFFF = 0xFFFE
      01110000000000000111000000000000000000: out = 1110000000000000011;     // Positive overflow
      11111111111111110000000000000001000000: out = 0000000000000000100;     // Negative overflow
      
      // Subtract test cases
      // TODO: Double check overflow bit result
      00000000000000000000000000000000000001: out = 0000000000000000100;     // 0 - 0 = 0
      01111111111111110000000000000000000001: out = 0111111111111111000;     // x - 0 = x
      00000000000000000111111111111111000001: out = 1000000000000001011;     // 0 - x = -x
      11111111111111110000000000000000000001: out = 1111111111111111001;     // (-x) - 0 = (-x)
      00000000000000000111111111111111000001: out = 1000000000000001011;     // 0 - (-x) = x
      01110110010101000101010000110010000001: out = 0010001000100010000;     // x - y, x > y > 0
      01010100001100100111011001010100000001: out = 1101110111011110011;     // x - y, y > x > 0
      11101101110010111101110010111010000001: out = 0001000100010001010;     // x - y, 0 > x > y
      11011100101110101110110111001011000001: out = 1110111011101111001;     // x - y, 0 > y > x
      01111111111111111000000000000000000001: out = 1111111111111111001;     // x - y, x > 0 > y
      10000000000000000111111111111111000001: out = 0000000000000001000;     // x - y, y > 0 > x
      
      // Multiplication
      // z, v, n output bits set to 0 since multiplier doesn't set these bits
      00000000000000000000000000000000000100: out = 0000000000000000100;     // 0 x 0
      00000000000000000111111111111111000100: out = 0000000000000000000;     // 0 x Positive
      00000000000000001111111111111111000100: out = 0000000000000000001;     // 0 x Negative
      01111111111111110000000000000000000100: out = 0000000000000000000;     // Positive x 0
      11111111111111110000000000000000000100: out = 0000000000000000001;     // Negative x 0
      00000000000001010000000000000011000100: out = 0000000000001111000;     // 5 x 3 = 15
      00000000000001011111111111111111000100: out = 1111111111111011000;     // 5 x -1 = -5
      11111111111111100000000000000100000100: out = 1111111111111000000;     // -2 x 4 = -8
      11111111111111101111111111111101000100: out = 0000000000000110001;     // -2 x -3 = 6
      01111111111111110111000000000000000100: out = 1001000000000000011;     // 32 767 x 28 672 = -28 672
      10000000000000001000111111111111000100: out = 1000000000000000010;     // -32 768 x -28 673 = -32 768
        
      // Boolean
      // z, v, n output bits set to 0 since boolean unit doesn't set these bits
      // XOR
      00000000000000000000000000000000010000: out = 0000000000000000100;  // 0x0000 ^ 0x0000 = 0x0000
      11111111111111111111111111111111010000: out = 0000000000000000001;  // 0xFFFF ^ 0xFFFF = 0x0000
      11111111111111110000000000000000010000: out = 1111111111111111001;  // 0xFFFF ^ 0x0000 = 0xFFFF
      01010101010101011010101010101010010000: out = 1111111111111111001;  // 0x5555 ^ 0xAAAA = 0x1111
      11111111111111110101010101010101010000: out = 1010101010101010000;  // 0xFFFF ^ 0x5555 = 0xAAAA
      // AND
      00000000000000000000000000000000010001: out = 0000000000000000100;  // 0x0000 * 0x0000 = 0x0000
      11111111111111111111111111111111010001: out = 1111111111111111110;  // 0xFFFF * 0xFFFF = 0xFFFF
      11111111111111110000000000000000010001: out = 0000000000000000001;  // 0xFFFF * 0x0000 = 0x0000
      01010101010101011010101010101010010001: out = 0000000000000000001;  // 0x5555 * 0xAAAA = 0x0000
      11011110101011010000000011111111010001: out = 0000000010101101001;  // 0xDEAD * 0x00FF = 0x00AD
      // "A"
      00000000000000000000000000000000010010: out = 0000000000000000100;  
      11111111111111110000000000000000010010: out = 1111111111111111001;
      10111110111011110000000000000000010010: out = 1011111011101111001;
      00010010001101001010101111001101010010: out = 0001001000110100001;  // Value of B doesn't affect output of ALU
      // OR
      00000000000000000000000000000000010011: out = 0000000000000000100;  // Self-explanatory
      11111111111111111111111111111111010011: out = 1111111111111111110;
      11111111111111110000000000000000010011: out = 1111111111111111001;
      01010101010101011010101010101010010011: out = 1111111111111111001;
      11011110000000000000000010101101010011: out = 1101111010101101001;
      
      // Bitshift
      // shift left
      11011110101011010000000000000101100000: out = 1101010110100000001;  // Shift to non-byte boundary
      11011110101011010000000000001000100000: out = 1010110100000000001;  // Shift to byte boundary
      11011110101011010000000000001111100000: out = 1000000000000000001;  // Shift to max shift
      // shift right
      11011110101011010000000000000101100001: out = 0000011011110101001;  // Shift to non-byte boundary
      11011110101011010000000000001000100001: out = 0000000011011110001;  // Shift to byte boundary
      11011110101011010000000000001111100001: out = 0000000000000001001;  // Shift to max shift
      // shift right arithmetic
      // Negative value
      11011110101011010000000000000101100010: out = 1111111011110101001;  // Shift to non-byte boundary
      11011110101011010000000000001000100010: out = 1111111111011110001;  // Shift to byte boundary
      11011110101011010000000000001111100010: out = 1111111111111111001;  // Shift to max shift
      // Positive value
      01111100101010110000000000000101100010: out = 0000001111100101000;  // Shift to non-byte boundary
      01111100101010110000000000001000100010: out = 0000000001111100000;  // Shift to byte boundary
      01111100101010110000000000001111100010: out = 0000000000000000000;  // Shift to max shift
      // rotate left
      11011110101011010000000000000101100011: out = 1101010110111011001;  // Rotate to non-byte boundary
      11011110101011010000000000001000100011: out = 1010110111011110001;  // Rotate to byte boundary
      11011110101011010000000000001111100011: out = 1110111101010110001;  // Rotate to max position
      // rotate right
      11011110101011010000000000000101100100: out = 0110111011110101001;  // Rotate to non-byte boundary
      11011110101011010000000000001000100100: out = 1010110111011110001;  // Rotate to byte boundary
      11011110101011010000000000001111100100: out = 1011110101011011001;  // Rotate to max position
      
      // Comparison
      // CMPEQ
      10000000000000001111111111111111110011: out = 0000000000000000001;  // Less than (Negative - Negative)
      10000000000000000000000000000000110011: out = 0000000000000000001;  // Less than (Negative - Zero)
      10000000000000000111111111111111110011: out = 0000000000000000000;  // Less than (Negative - Positive)
      00000000000000000111111111111111110011: out = 0000000000000000001;  // Less than (Zero - Positive)
      00000000000000010111111111111111110011: out = 0000000000000000001;  // Less than (Positive - Positive)
      
      10000000000000001000000000000000110011: out = 0000000000000001110;  // Equal to (Negative - Negative)
      00000000000000000000000000000000110011: out = 0000000000000001100;  // Equal to (Zero - Zero)
      01111111111111110111111111111111110011: out = 0000000000000001100;  // Equal to (Positive - Positive)
      
      11111111111111111000000000000000110011: out = 0000000000000000010;  // Greater than (Negative - Negative)
      00000000000000001000000000000000110011: out = 0000000000000000001;  // Greater than (Zero - Negative)
      01111111111111111000000000000000110011: out = 0000000000000000001;  // Greater than (Positive - Negative)
      01111111111111110000000000000000110011: out = 0000000000000000000;  // Greater than (Positive - Zero)
      01111111111111110000000000000001110011: out = 0000000000000000000;  // Greater than (Positive - Positive)
      
      // CMPLT
      10000000000000001111111111111111110101: out = 0000000000000001001;  // Less than (Negative - Negative)
      10000000000000000000000000000000110101: out = 0000000000000000001;  // Less than (Negative - Zero)
      10000000000000000111111111111111110101: out = 0000000000000000000;  // Less than (Negative - Positive)
      00000000000000000111111111111111110101: out = 0000000000000001001;  // Less than (Zero - Positive)
      00000000000000010111111111111111110101: out = 0000000000000001001;  // Less than (Positive - Positive)
      
      10000000000000001000000000000000110101: out = 0000000000000000110;  // Equal to (Negative - Negative)
      00000000000000000000000000000000110101: out = 0000000000000000100;  // Equal to (Zero - Zero)
      01111111111111110111111111111111110101: out = 0000000000000000100;  // Equal to (Positive - Positive)
      
      11111111111111111000000000000000110101: out = 0000000000000000010;  // Greater than (Negative - Negative)
      00000000000000001000000000000000110101: out = 0000000000000001001;  // Greater than (Zero - Negative)
      01111111111111111000000000000000110101: out = 0000000000000001001;  // Greater than (Positive - Negative)
      01111111111111110000000000000000110101: out = 0000000000000000000;  // Greater than (Positive - Zero)
      01111111111111110000000000000001110101: out = 0000000000000000000;  // Greater than (Positive - Positive)
      
      // CMPLE
      10000000000000001111111111111111110111: out = 0000000000000001001;  // Less than (Negative - Negative)
      10000000000000000000000000000000110111: out = 0000000000000000001;  // Less than (Negative - Zero)
      10000000000000000111111111111111110111: out = 0000000000000000000;  // Less than (Negative - Positive)
      00000000000000000111111111111111110111: out = 0000000000000001001;  // Less than (Zero - Positive)
      00000000000000010111111111111111110111: out = 0000000000000001001;  // Less than (Positive - Positive)
      
      10000000000000001000000000000000110111: out = 0000000000000001110;  // Equal to (Negative - Negative)
      00000000000000000000000000000000110111: out = 0000000000000001100;  // Equal to (Zero - Zero)
      01111111111111110111111111111111110111: out = 0000000000000001100;  // Equal to (Positive - Positive)
      
      11111111111111111000000000000000110111: out = 0000000000000000010;  // Greater than (Negative - Negative)
      00000000000000001000000000000000110111: out = 0000000000000001001;  // Greater than (Zero - Negative)
      01111111111111111000000000000000110111: out = 0000000000000001001;  // Greater than (Positive - Negative)
      01111111111111110000000000000000110111: out = 0000000000000000000;  // Greater than (Positive - Zero)
      01111111111111110000000000000001110111: out = 0000000000000000000;  // Greater than (Positive - Positive)
      
      default: out = c{16h0, 0, 0, 0}; // Hopefulle we never reach here, but if we do, output all zeroes
    }
  }
}