module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input usb_rx,           // USB->Serial input
    output usb_tx,          // USB->Serial output
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8]     // DIP switches on IO Shield
  ) {
  
  sig rst;                    // reset signal
  sig error_out[16];              // signal to hold our error
  alu sixteen_bit_alu;        // Our main ALU
  answer_rom rom;             // Our ROM containing the correct answers for each ALU operation
  // Binary-to-Decimal component converts our running count binary value to the required 4-digit
  // form needed for our multi-seven-segment module, e.g. 1010 -> {0000, 0000, 0001, 0000}
  bin_to_dec btd(#DIGITS(4)); 
  
  const NUM_STATES = 110;     // Convenience constant to specify the number of states in our FSAM
  const NUM_STATE_BITS = $clog2(NUM_STATES);  // How many bits required to encode our specified number of states
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    button_conditioner btn_cnd(#CLK_FREQ(100000000));  // Button conditioner to debounce our IO_button
    
    .rst(rst) {
      answer_fsm ans(#STATES(NUM_STATE_BITS));  // Init our answer FSM (which requires both clk and rst signal)
      multi_seven_seg seg;                      // Init our multi-seven-seg module (which requires both clk and rst signal)
    }
  }
  
  .rst(rst) {
      // Init our counter outside of the .clk() block so that we can pause its incrementing later on (specified below)
      // Init with output size corresponding to number of FSM bits, and divide the clock signal by 26 bits to slow it down
      // We specify our top as the max number of states, so that it loops back to 0 after
      counter cnt(#SIZE(NUM_STATE_BITS), #DIV(26), #TOP(NUM_STATES));
  }
  
  always {
    btn_cnd.in = io_button[0];  // Set our io_button[0] (top button) as the input to our button conditioner
    
    // By setting the clk of our counter as such, we can pause operation by flipping the leftmost dip switch to high,
    // then step through each output of the FSM by pressing our io_button[0] (which has been conditioned and debounced)
    cnt.clk = clk & (!io_dip[2][7] | btn_cnd.out);
    
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    usb_tx = usb_rx;        // loop serial port
    
    led = 8h00;             // turn LEDs off
    
    io_led = 3x{{8h00}};    // turn LEDs off
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits
    
    ans.in = cnt.value;     // Our counter steps through each state and output of each state
    
    // Since the output of our answer FSM is formatted as {a, b, alufn}, 
    sixteen_bit_alu.a = ans.out[37:22];    // We take the first 16 bits and pass it to the a input of our ALU
    sixteen_bit_alu.b = ans.out[21:6];     // We take the next 16 bits and pass it to the b input of our ALU
    sixteen_bit_alu.alufn = ans.out[5:0];  // We take the last 6 bits and pass it to the alufn input of our ALU
    
    rom.address = ans.out;  // We also pass it to our ROM to get the correct answer
    
    // The first 3 LEDs of the leftmost bank indicate the z, v, n outputs of our ALU
    io_led[2][7:5] = c{sixteen_bit_alu.z, sixteen_bit_alu.v, sixteen_bit_alu.n};  
    
    // The next 3 LEDs indicate the z, v, n outputs of our ROM
    io_led[2][4:2] = c{rom.out[2], rom.out[1], rom.out[0]};
    
    // Error case by flipping the second-from-the-left dipswitch to invert the LSB of the ALU output
    error_out = sixteen_bit_alu.out ^ c{15b0, io_dip[2][6]};  
    io_led[2][1] = io_dip[2][6];  // Leftmost bank, second from the right LED is on if our error is active
    
    // The next 2 banks of LEDs indicate the output of our ALU
    io_led[1:0] = $build(error_out, 2);
    
    // The rightmost LED of the leftmost bank indicates the correctness of our ALU by XOR-ing each output, then OR-ing all the results
    // If the light is on, there is an error
    // If the light is off, the output is equivalent hence correct
    io_led[2][0] = ((|(rom.out[18:3] ^ error_out)) |
                    (rom.out[2] ^ sixteen_bit_alu.z) | 
                    (rom.out[1] ^ sixteen_bit_alu.v) | 
                    (rom.out[0] ^ sixteen_bit_alu.n));
    
    btd.value = cnt.value;    // Get the 4-digit representation of our counter value
    seg.values = btd.digits;  // and pass it to our seven-segment display module to parse
    
    io_seg = ~seg.seg; // connect segments to the driver
    io_sel = ~seg.sel; // connect digit select to the driver
  }
}