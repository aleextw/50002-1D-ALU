init:
SVC()
BEQ(R0, init, R31)

SHRC(R0, 4, R0) || Shift R0 right by 4 bits to get MSB of 5-bit value
BF(R0, init, R31) || If MSB == 1, means we pressed the start button, continue, else branch back to start and wait for button input
CMOVE(1, R26) || Add 1 to our level count R26

start:
|| If R26 == 1, branch to level_one_setup
CMPEQC(R26,1,R0) || if R26 == 1, then R0 is 1, else R0 is 0
BT(R0, level_one_setup, R31) 
|| elif R26 == 2, branch to level_two_setup
CMPEQC(R26,2,R0)
BT(R0, level_two_setup, R31)
|| elif R26 == 3, branch to level_three_setup
CMPEQC(R26,3,R0)
BT(R0, level_three_setup, R31)

|| else endgame
CMOVE(-1, R24)
game_end_light_loop:
SHRC(R24, 1, R24)
BT(R24, game_end_light_loop, R24)
BF(R31, init, R31)


|| TODO: Add randomization to setup to load different level one / two stages
|| TODO: Add position arrays
level_one_setup:
LD(level_one_position, R24) || Load level one peg positions to R24
BF(R31, array_setup, R31) || Branch to array_setup

level_two_setup:
LD(level_two_position, R24) || Load level two  peg positions to R24
BF(R31, array_setup, R31) || Branch to array_setup

level_three_setup: 
RAND(R0) || Store random value to R0
XORC(R0, 65535, R24)
BF(R31, array_setup, R31) || Branch to array_setup

array_setup: 
CMOVE(0, R1) || Set R1 to 0 to use as our counter
CMOVE(1, R0) || Set R0 to 1 to use as our mask

array_setup_loop: 
SHR(R24, R1, R2) || to get the i-th peg as the LSB
AND(R2, R0, R3) || returns 1 if a peg is at the i-th position, and 0 if there is no peg
SHLC(R1, 1, R4) || gives us the array index, accounting for the 2-byte indexing of our data memory
ST(R3, pegboard_array, R4) || stores our result of whether there is a peg in the i-th position in our data memory
ADDC(R1, 1, R1)
|| If R1 == 15, we have written our entire pegboard to our array, continue with game
CMPEQC(R1,15,R5) || if R1 == 15, then R5 is 1, else R5 is 0
BF(R5, array_setup_loop, R31) || Else, branch back to array_setup

game_start:
MOVE(R31, R23) || Set our 'currently selected peg' register to be 0
MOVE(R31, R25) || Set our 'possible moves' register to be 0

CMOVE(0, R3)


test_loop:
LD(R3, pegboard_array, R4)  || Get status of peg at space position
ADDC(R3, 2, R3)
CMPEQC(R3, 30, R2)
BT(R2, game_start, R31)
BF(R2, test_loop, R31)


. = 256
button_handler:
MOVE(R31, R22)
button_handler_loop:
BEQ(R22, button_handler_loop, R31)
MOVE(R22, R0)
MOVE(R31, R22)
JMP(XP, R31)

